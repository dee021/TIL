# Index
- 인덱스는 모든 값을 정렬된 순서로 보관
- 몽고DB는 쿼리당 하나의 인덱스만 사용
  - 예외. $or 연산자는 두 개의 쿼리를 수행하고 결과를 합침 / 절마다 하나씩 인덱스 사용
    - $or 보다 $in 사용 권장

## 인덱스 vs 컬렉션 스캔
인덱스 스캔 : 1) 인덱스 항목을 살펴보고 2) 도큐먼트를 가리키는 인덱스 포인터를 따라감
- 컬렉션에서 가져와야 하는 부분이 많을수록 비효율적
컬렉션 스캔 : 도큐먼트만 살핌

=> 최악의 경우 : 컬렉션의 모든 도큐먼트를 반환해야 할 때, 인덱스를 사용하면 컬렉션 스캔보다 두 배의 조회

## 인덱스의 특징
1) 쿼리를 수행할 때 인덱스가 없다면 모든 도큐먼트를 일일이 조회해야 한다. 인덱스는 쿼리 작업을 매우 효율적으로 만든다.
2) 인덱스를 만들면 새로운 도큐먼트를 생성하거나 제거하는 작업을 빈번하게 할 때 속도의 저하가 일어날 수 있다. 매번 인덱스를 업데이트해야 하기 때문이다.
3) 단순 인덱스를 만들면 해당 필드만 조회할 때 사용할 수 있고, 다수의 필드를 대상으로 조회를 할 때에는 복합 인덱스가 필요하다.
4) 복합 인덱스는 순서가 중요하다.
5) a-b 복합 인덱스는 a 단순 인덱스와 같은 기능을 하기 때문에 대체할 수 있다.

## 인덱스의 구조
: 인덱스는 필드의 값을 기반으로 도큐먼트들을 가리키는 포인터 값으로 이뤄진 B-Tree 구조를 만든 것

MongoDB에서 인덱스는 어떤 필드에 대한 값을 검색하기 쉽도록 B-Tree 구조로 만들어 저장
- 이때 인덱스를 만들기 위해 기준으로 삼은 필드의 값들은 '인덱스키'

MongoDB에서 _id 필드는 도큐먼트에 대해 각각 하나의 값을 가짐(Primary Key)
- _id 필드는 컬렉션이 생성될 때 자동으로 인덱스가 생성됨
- 쿼리 작성 시 필터에 "_id"를 사용해도 효율적

#### B-Tree 구조
: 하나의 노드가 가질 수 있는 자식 노드의 숫자가 2보다 큰 트리 구조

트리 규칙
- 각 노드에 있는 키들은 전부 정렬되어 있어야 한다.
- 부모 노드의 키들 사이사이와 자식 노드들이 연결되어 있다.

<b>균형 맞춤</b> : 도큐먼트를 추가/삭제 시 검새 효율을 고려하여 각 노드에 키를 추가하기도 하고 노드를 쪼개거나 합치기도 하는 과정
- 정말 필요한 인덱스가 아니면 생성하지 않는 것이 좋고
- 생성 및 삭제 작업이 빈번하다면 인덱스를 만들지 않는 것도 고려해야 함

## 인덱스의 종류
### 필드 수에 따른 인덱스의 종류
#### 단일키 인덱스
: 한 가지 종류의 인덱스 키 값을 갖는 방식
- 특정 값과 범위 그리고 정렬 시에 유용
  - 오름차순 | 내림차순 정렬 시 인덱스의 정보를 그대로 활용

한계
- 서로 다른 필드에 대하여 각각 정렬이 불가능
- 두 가지의 필드의 값을 한 번에 검색 불가능

#### 복합키(Compound) 인덱스
: 여러 가지 필드의 값들을 키로 하는 인덱스

- 어떤 키를 우선으로 할지가 매우 중요
- 어떤 형식이든 인덱스 생성이 가능
  - MongoDB는 숫자 이외에 모든 데이터 타입에 대해 대소비교가 가능
- 복합키 인덱스는 단일키 인덱스의 기능을 모두 포함
    - 여러 가지 필드의 범위 검색과 값 검색, 정렬이 가능
- 복합키 인덱스를 이용한 정렬 시 복합키 인덱스의 정렬 방향과 선후 관계가 매우 중요
- 복합키 인덱스를 이용한 검색 시 인덱스키의 선후 관계가 다르더라도 원하는 필드가 모두 포함되어 있다면 사용 가능
  - 더 포괄적인 필드(값의 중복이 빈번한 필드)에 우선권을 주면 상대적으로 적은 횟수의 탐색으로 결과를 얻을 수 있음

### 값의 형태에 따른 인덱스의 종류
#### 다중키(multikey) 인덱스
MongoDB는 배열 값에 대한 검색 상황을 대비해 '배열에 대한 인덱스'를 지원

- 다중키 인덱스는 배열 속의 각각의 값을 인덱스 키로 저장
- 배열 속의 임베디드 방식의 모델링을 하는 경우에도 내부 도큐먼트들을 검색하기 우해 인덱스를 만들 수 있다.
  - 다중키 인덱스를 만들 때 배열을 값으로 하는 필드를 인덱싱하거나, 배열 속 임베디드 도큐먼트 필드를 가리키면 자동으로 생성됨

#### 텍스트 인덱스
: 단어 단위, 단어의 원형으로 검색이 가능한 인덱스
- $text 연산자를 사용하기 위해 반드시 먼저 생성되어야 하는 인덱스
- 한국어의 경우 형태소 분석이 불가능
  - 단어 단위로 인덱싱하게 됨
- 하나의 컬렉션에 단 하나만 생성 가능
  - 복합키 방식을 사용할 수 있기 때문에 복합키로 만들면 된다.
- 단어 단위로 인덱싱을 하기 때문에 정렬할 때 활용 불가
- text 인덱스에서 필요한 키의 개수는 인덱싱되는 필드의 단어 개수에 비례
  - 시스템 리소스가 많이 소비됨

#### 지리공간적 인덱스
: 지리 정보를 보다 효과적으로 검색하기 위한 인덱스

### 해시 인덱스
: B-Tree 구조와 해시화 함수를 이용해 인덱싱한 인덱스
- 값을 직접 인덱싱하지 않고, 해시화 함수를 통해 더 작은 크기로 변형된 값을 B-Tree 구조로 인덱싱
  - 기존 인덱싱 보다 훨씬 작고, 값 검색 속도가 빨라짐
- 원래의 값을 변형하므로 범위 검색과 정렬에 인덱스 활용이 불가능

제약
- 해시 인덱스 필드를 포함한 복합키 인덱스를 생성할 수 없다.
- 배열을 값으로 가지는 필드에 설정할 수 없다.
  - 배열 자체를 해시화하여 저장하기 때문

해시 샤딩을 할 때 주로 사용하는 것이 일반적이며, 값 검색을 더 빠르게 해야 하는 상황에서 고려할만 함.

## 인덱스 관련 조작
### 인덱스 생성
: 인덱스 구축 시 인덱스 옵션을 지정하여 동작 방식을 바꿀 수 있음
```
db.collection_name.createIndex(<keys>[, 
    {
        background: <document>,
        unique: <boolean>,
        name: <string>,
        partialFilterExpression: <document>,
        sparse: <boolean>,
        expieAfterSeconds: <numbers>
    }
])
```
- keys : 필드-값 쌍을 갖는 도큐먼트. 값은 필드의 인덱스 유형을 지정
- options : 고유 인덱스, 부분 인덱스를 지정하거나 인덱스명을 지정할 수 있음


#### 종류에 따른 인덱스 생성 예시
```
db.collection_name.createIndex(
    {<field>: <1|-1>, ...}
)

// 단일키 인덱스
db.movie.createIndex(
    {평점: 1}
)
```
- <1 | -1> : 오름차순 | 내림차순 인덱스 지정
- inverse index(역방향 인덱스)는 서로 동등함
    - {"age": 1, "username": -1}와 {"age": -1, "username": 1}는 서로 동등

```
// 복합키 인덱스
db.movie.createIndex(
    {평점: 1, 점수: -1}
)
```
- 복합 인덱스 구성 시 정렬 키를 첫 번째에 놓는 것이 좋음
- 복합 인덱스 구성 시 고려사항
    - 동등 필터에 대한 키를 맨 앞에 표시해야 한다.
    - 정렬에 사용되는 키는 다중값 필드 앞에 표시해야 한다.
    - 다중값 필터에 대한 키는 마지막에 표시해야 한다.
- 복합 인덱스는 '이중 임무'를 수행할 수 있으며, 쿼리마다 다른 인덱스 처럼 동작할 수 있음
    - {"a": 1, "b": 1, ..., "z": 1} 인덱스가 있을 때
     사실상 {"a": 1}, {"a": 1, "b": 1}, ... 등으로 인덱스를 가짐

```
// 다중키 인덱스
// 리뷰 : [{제목: 'title', 내용: 'content'}, ...] 형식일 때
db.movie.createIndex(
    {"리뷰.제목": 1} 
)

// 해시 인덱스
db.movie.createIndex(
    {배급사: "hashed"}
)
```


텍스트 인덱스
```
db.collection_name.createIndex(
    {key1:"text"[, key2:"text"] }[,
    {
        weights: {key1:n, key2:m, ...},
        default_language: <language>
    }
])

db.movie.createIndex(
    {제목: "text"}
)
```
- "$**"에 인덱스를 만들면 도큐먼트의 모든 문자열 필드에 전문 인덱스를 생성
    - 최상위 문자열 필드뿐 아니라 내장 도큐먼트와 배열에서 문자열 필드를 검색
- weights : keyn, keym에 n:m의 가중치를 부여
    - 인덱스를 생성한 후 필드 가중치를 변경할 수 없음
- default_language: 기본값 english. 언어에 따라 형태소 분석 방법이 다르며, 해당 옵션을 지정하여 언어를 지정할 수 있음

text 검색

: $text 쿼리 연산자를 사용하여 검색
- 공백과 구두점(punctuation)을 기호(delimiter)로사용해 검색 문자열을 토큰화하며, 검색 문자열에서 모든 토큰의 논리적 OR을 수행
- AND를 사용하려면 텍스트를 큰따옴표로 묶을 수 있음
```
{$text:{$search:"\"AAA\" B C"}} 
// "AAA" AND ("B" OR "C")로 처리
```
- 각 쿼리 결과에 메타데이터가 연결되며, $meta 연산자에 "textScore"를 명시하여 관련성 스코어를 표기할 수 있음


#### 옵션에 따른 인덱스 생성 예시
형식
```
db.collection.createIndex(
    {<field>: <1 or -1>, <field>: <1 or -1>, ...},
    {
        background: <document>,
        unique: <boolean>,
        name: <string>,
        partialFilterExpression: <document>,
        sparse: <boolean>,
        expireAterSeconds: <number>
    }
)
```

인덱스 이름 정하기
```
db.movie.createIndex(
    {배급사:"hashed"}, 
    {name: "배급사 해시 인덱스"}
)
```

<b>TTL(Time To Live) 인덱스</b>: 도큐먼트에 유효 시간을 설정하는 인덱스
```
db.collection_name.createIndex(
    {<date_field>:<direct>}, 
    {<expireAterSenconds>:<time(second)>}
)

db.movie.createIndex(
    {expire:1},
    {expireAfterSeconds: 3600}
)
```
- 시간을 나타내는 필드 혹은 배열 속에 시간 값을 가진 필드를 인덱스로 설정해야 함
  - 필드의 값이 배열이면 가장 빠른 시간(최근 시간)을 기준으로 작동
- 키를 하나만 갖는 단일키 인덱스여야 함
- date_field가 날짜형이면, 서버 시간이 time(s) 지난 후 도큐먼트가 삭제됨
  - 삭제 처리는 60초에 한번씩 MongoDB가 만료된 도큐먼트를 찾아 삭제
- collMod 명령을 이용하여 expireAterSenconds를 변경할 수 있음

<b>고유 인덱스</b>: 각 값이 인덱스에 최대 한 번 나타나도록 보장
```
db.movie.createIndex(
    {제목: 1},
    {unique: true}
)
```
- unique 옵션 지정
- 도큐먼트에 키가 존재하지 않으면 인덱스는 그 도큐먼트에 대해 값을 null로 저장. 
    - 인덱싱된 필드가 없는 도큐먼트를 2개 이상 삽입할 수 없음
    - 처리 방안 : 부분 인덱스
- 8KB보다 긴 키에는 고유 인덱스 제약 조건이 적용되지 않음

<b>복합 고유 인덱스</b>: 개별 키는 같은 값을 가질 수 있지만 인덱스 항목의 모든 키에 걸친 값의 조합은 인덱스에서 최대 한 번 나타남.

희소 인덱스
```
db.drawing.createIndex(
    {제목: 1}, 
    {sparse: true, unique: true}
)
```

<b>부분 인덱스</b>: 키가 존재하는 도큐먼트에 대해서만 인덱스 생성
```
db.collection_name.createIndex(
    <keys>, 
    <partialFilterExpression> : {
        <unique_key>: <value | expression>
    }
)

db.movie.createIndex(
    {제목: 1}, 
    {partialFilterExpression: {제목:"무제"} }
)

db.contacts.createIndex(
    { name: 1 },
    { partialFilterExpression: 
        { email: { $exists: true } } 
    }
)
```
- partialFilterExpression 옵션값에 사용할 수 있는 연산자
  - 같다는 의미의 $eq 연산자
  - $exists: true 표현
  - 비교 연산자 중 $gt, $gte, $lt, $lte 연산자
  - $type 연산자
  - 가장 상위 단계의 $and 연산자
- unique와 partial을 결합하여 키가 존재하는 도큐먼트에 대하여 고유 인덱스를 생성할 수 있음

### 인덱스 관리
- 데이터베이스의 인덱스 정보는 모두 system.indexes 컬렉션에 저장된다.
  - 인덱스 생성 시 system.indexes에서 인덱스의 메타 정보를 확인 할 수 있음
  - 예약된 컬렉션이므로 안에 있는 도큐먼트 수정/제거할 수 없음
  - createIndex, createIndexes, dropIndexes와 같은 명령으로만 조작 가능

특정 컬렉션의 모든 인덱스 정보 확인
```
db.collection_name.getIndexes()
```

예시 및 반환
```
> db.users.getIndexes()
[
        {
                "v" : 2,
                "key" : {
                        "_id" : 1
                },
                "name" : "_id_"
        },
        {
                "v" : 2,
                "key" : {
                        "age" : 1,
                        "username" : 1
                },
                "name" : "age_1_username_1"
        }
]
```
- v : index versioning. 해당 값이 없는 인덱스는 오래되고 비효율적인 형식으로 저장된 상태
- key : 인덱스 설계 구조
- name : 인덱스명. dropIndexes와 같은 인덱스 관리 작업에서 식별자로 사용
  - 인덱스 생성 시 지정하지 않으면 '키명1_방향1_...키명N_방향N' 형태로 지정됨
  - 글자 수 제한이 있으므로 사용자 지정 이름이 필요할 수 있음

<b>인덱스 삭제</b>
```
// 특정 인덱스 삭제
db.collection_name.dropIndex(<인덱스 이름>) 
db.collection_name.dropIndex(<인덱스 설정>)

// 해당 컬렉션의 모든 인덱스 삭제
db.cllection_name.dropIndexes()

```
